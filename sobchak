#!/usr/bin/env python3

# Sobchak
# An OpenStack instance scheduling optimizer.

import logging
import argparse
import os
import base64

from matplotlib import pyplot
from io import BytesIO

from keystoneauth1.identity import v3
from keystoneauth1 import session as keystone_session
from keystoneclient.v3 import client as keystone_client
from novaclient import client as nova_client

from novaclient.v2.servers import Server
from novaclient.v2.hypervisors import Hypervisor

from time import sleep

# Load openrc values
try:
    PROJECT_ID = os.environ['OS_PROJECT_ID']
    AUTH_URL = os.environ['OS_AUTH_URL']
    USERNAME = os.environ['OS_USERNAME']
    PASSWORD = os.environ['OS_PASSWORD']
except KeyError:
    logging.error('Please source your OpenStack openrc file.')
    raise


def get_object_by_id(objects, identifier):
    """get_object_by_id

    Returns the object which belongs to the given ID. Returns None if it wasn't
    found.
    """
    logging.debug('Searching for %s inside %s', identifier, objects)
    for obj in objects:
        if obj.id == identifier or obj.name == identifier:
            return obj
    logging.info('Could not find %s inside %s', identifier, objects)
    return None


class Session(keystone_session.Session):
    """Session

    Maintains an OpenStack session which can be used by the clients.
    """

    def __init__(self):
        auth = v3.Password(
            auth_url=AUTH_URL,
            username=USERNAME,
            password=PASSWORD,
            project_id=PROJECT_ID,
            user_domain_name='Default')
        keystone_session.Session.__init__(self, auth=auth)


class Inventory(object):
    """Inventory

    An object containing Hypervisor and VM objects which are fetched using the
    OpenStack API.
    """

    def __init__(self, novaclient, config={}):
        self._client = novaclient
        self._config = config
        self._hypervisors = []
        self._vms = []
        self._flavors = []

    def to_dict(self):
        """to_dict

        Returns the inventory as a dictionary.
        """
        return {
                'common_ratio': self.common_ratio,
                'inventory': [ h.to_dict() for h in self.hypervisors ]
                }

    def generate_report(self):
        """generate_report

        Generates a report in HTML-format.
        """
        wrapper = '<img src="data:image/png;base64,{}" />'
        return ''.join([ wrapper.format(h.plot) for h in self.hypervisors ])

    @property
    def hypervisors(self):
        """hypervisors

        Returns a list of hypervisors as CustomHypervisor objects. If it's the
        first time the list is being called, the VM's are attached to their
        hypervisors.
        """
        if not self._hypervisors:
            self._hypervisors = [
                    CustomHypervisor(h, self.common_ratio, self._config)
                    for h in self._client.hypervisors.list() ]

            for vm in self.vms:
                hypervisor = get_object_by_id(self._hypervisors, vm.hypervisor)
                if not hypervisor:
                    raise ValueError('Unknown hypervisor for %s (status: %s)',
                            vm.name, vm.status)
                hypervisor.add_server(vm)

        return self._hypervisors

    @property
    def vms(self):
        """vms

        Returns a list of VM's as CustomServer objects.
        """
        if not self._vms:
            opts = { 'all_tenants': True }
            self._vms = [ CustomServer(vm, self.flavors) \
                    for vm in self._client.servers.list(search_opts=opts)
                    if vm.status != 'SHELVED_OFFLOADED' ]

        return self._vms

    @property
    def common_ratio(self):
        """common_ratio

        Returns the most common ratio amongst all VMs.
        """
        ratios = [ vm.ratio for vm in self.vms ]
        return max(ratios, key=ratios.count)

    @property
    def flavors(self):
        """flavors

        Returns a list of Flavors.
        """
        if not self._flavors:
            self._flavors = self._client.flavors.list(is_public=None)

        return self._flavors

    def optimize(self):
        """optimize

        Generates and returns a list of migrations to improve Hypervisor
        resource distribution.
        """
        # TODO
        return []


class CustomHypervisor(Hypervisor):
    """CustomHypervisor

    A CustomHypervisor object contains information about its available resources
    and the VMs it hosts.
    """

    def __init__(self, hypervisor, common_ratio, config={}):
        # TODO implement overhead and overcommit factors
        Hypervisor.__init__(self, hypervisor.manager, hypervisor._info)
        self._servers = []
        self._common_ratio = common_ratio
        self._ram_overcommit = config.get('ram_overcommit', 1)
        self._cpu_overcommit = config.get('cpu_overcommit', 4)
        self._memory_overhead = config.get('hypervisor_memory_overhead', 32)
        logging.debug('Initialized hypervisor: %s', self.id)

    def to_dict(self):
        """to_dict

        Returns the hypervisor as a dict.
        """
        dictionary = {
            'id': self.id,
            'name': self.name,
            'score': self.score(self._common_ratio),
            'enabled': self.enabled,
            'vcpus': self.vcpus,
            'vcpus_used': self.vcpus_used,
            'memory_mb': self.memory_mb,
            'memory_mb_used': self.memory_mb_used,
            'vms': [ s.to_dict() for s in self._servers ],
        }
        return dictionary

    @property
    def plot(self):
        """plot

        Generates a plot of the hypervisor and its resources and returns it as a
        Base64 decoded string.
        """
        # Generate a plot
        x = [ i for i in range(100) ]
        y = [ i**2 for i in x ]
        pyplot.plot(x, y)

        # Create PNG file in memory
        png_file = BytesIO()
        pyplot.savefig(png_file, format='png')

        # Return the PNG file as a Base64 string
        return base64.encodestring(png_file.getvalue()).decode('utf-8')

    @property
    def name(self):
        """name

        Returns the hypervisor domain name.
        """
        return self.hypervisor_hostname

    @property
    def enabled(self):
        """enabled

        Returns True if the hypervisor is enabled.
        """
        return self.status == 'enabled'

    @property
    def available_ram(self):
        """available_ram

        Returns the amount of available RAM in MB's, taking memory overhead and
        the overcommit ratio into account.
        """
        available_ram = self.memory_mb * self._ram_overcommit \
            - self.memory_mb_used - self._memory_overhead

        if available_ram < 0:
            logging.warning('Used memory above overcommit treshold on %s',
                    self.name)
            return 0

        return self.memory_mb * self._ram_overcommit - self.memory_mb_used

    @property
    def available_vcpus(self):
        """available_vcpus

        Returns the number of available VCPU's.
        """
        available_vcpus = self.vcpus * self._cpu_overcommit - self.vcpus_used

        if available_vcpus < 0:
            logging.warning('Used vCPUS above overcommit treshold on %s',
                    self.name)
            return 0

        return self.vcpus * self._cpu_overcommit - self.vcpus_used

    @property
    def ratio(self):
        """ratio

        Returns the ratio between the available RAM (in MB's) and the available
        number of vCPU's.
        """
        if not self.available_vcpus:
            return self.available_ram
        return int(self.available_ram / self.available_vcpus)

    def score(self, common_ratio):
        """score

        Returns a score based on the difference between the most common RAM/vCPU
        ratio amongst VMs and the RAM/vCPU ratio of available resources of this
        hypervisor. The closer to zero, the better the score.
        """
        def _sigmoid(x):
            """_sigmoid

            A sigmoid-like function.
            """
            return x / (1 + abs(x))

        weight_ram = _sigmoid( self.available_ram / self.memory_mb )
        weight_vcpus = _sigmoid( self.available_vcpus / self.vcpus )
        return (common_ratio - self.ratio) * (weight_ram + weight_vcpus)

    def add_server(self, server):
        """add_server

        Adds an OpenStack instance to the Hypervisor.
        """
        self._servers.append(server)


class CustomServer(Server):
    """CustomServer

    A CustomServer object contains information about an OpenStack instance and
    the resources it needs.
    """

    def __init__(self, server, flavors):
        Server.__init__(self, server.manager, server._info)
        self._flavor = get_object_by_id(flavors, self.flavor['id'])
        logging.debug('Initialized server: %s', self.id)

    def to_dict(self):
        """to_dict

        Returns information about this server as a dictionary.
        """
        dictionary = {
            'id': self.id,
            'ram': self.ram,
            'vcpus': self.vcpus,
            'ratio': self.ratio,
        }
        return dictionary

    @property
    def ram(self):
        """ram

        Returns the memory which is assigned to this server in MB's.
        """
        return self._flavor.ram

    @property
    def vcpus(self):
        """vcpus

        Returns the number of virtual CPU's which are assigned to this server.
        """
        return self._flavor.vcpus

    @property
    def ratio(self):
        """ratio

        Returns the RAM/vCPU ratio, rounded down to the nearest integer to allow
        ratio comparison as it prevents floating point comparison issues.
        """
        return int(self.ram/self.vcpus)

    @property
    def hypervisor(self):
        """hypervisor

        Returns the hypervisor hostname.
        """
        return self.__getattr__('OS-EXT-SRV-ATTR:hypervisor_hostname')


def parse_config(filename):
    """parse_config

    Load a certain YAML-file and return its contents as a dictionary.
    """
    try:
        with open(filename, 'r') as config:
            return yaml.safe_load(config)
    except Exception as e:
        logging.error('Could not load %s: %s', filename, e)
        exit(1)


def parse_args():
    """parse_args

    As always, parse given arguments using the usual argparse module and return
    the parsed args object.
    """
    parser = argparse.ArgumentParser(description="""
       _|_|_|            _|                  _|                  _|
     _|          _|_|    _|_|_|      _|_|_|  _|_|_|      _|_|_|  _|  _|
       _|_|    _|    _|  _|    _|  _|        _|    _|  _|    _|  _|_|
           _|  _|    _|  _|    _|  _|        _|    _|  _|    _|  _|  _|
     _|_|_|      _|_|    _|_|_|      _|_|_|  _|    _|    _|_|_|  _|    _|

> You mark that frame an eight, you're entering a world of pain. A world of
> pain.
                                                              ~ Walter Sobchak

Sobchak is your friendly neighbourhood OpenStack instance scheduling optimizer,
which generates a list of instance migrations to optimally make use of
hypervisor resources.
""", formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('-c', '--configfile', action='store',
                        help='Configuration file.')
    parser.add_argument('-d', '--debug',
                        help='Enable debug', action='store_true')
    parser.add_argument('-R', '--generate-report',
                        help='Generate a report', action='store_true')

    return parser.parse_args()


def run(configfile, debug, generate_report):
    """run

    Actually run the program; fetch a Hypervisor-VM inventory and determine
    which migrations can be executed to improve the current resource
    distribution.
    """
    if debug:
        logging.basicConfig(
            level=logging.DEBUG,
            format='%(asctime)s %(levelname)-8s %(message)s'
        )

    # Parse configfile (if given)
    config = {}
    if configfile:
        config = parse_config(configfile)
        logging.debug('Loaded config: %s', config)

    # Create OpenStack Nova client
    sess = Session()
    keystone = keystone_client.Client(session=sess)
    nova = nova_client.Client('2', session=sess)

    # Create inventory
    inventory = Inventory(nova, config)

    # Generate report (if needed)
    if generate_report:
        with open('report.html', 'w+') as report:
            report.write(inventory.generate_report())
            print('Report available: {}'.format(os.path.abspath('report.html')))

if __name__ == "__main__":
    args = parse_args()
    kwargs = vars(args)
    run(**kwargs)
