#!/usr/bin/env python3

# Sobchak
# An OpenStack instance scheduling optimizer.

import logging
import argparse
import os
import base64

from matplotlib import pyplot, patches
from io import BytesIO
from math import atan

from keystoneauth1.identity import v3
from keystoneauth1 import session as keystone_session
from keystoneclient.v3 import client as keystone_client
from novaclient import client as nova_client

from novaclient.v2.servers import Server
from novaclient.v2.hypervisors import Hypervisor

from time import sleep

# Load openrc values
try:
    PROJECT_ID = os.environ['OS_PROJECT_ID']
    AUTH_URL = os.environ['OS_AUTH_URL']
    USERNAME = os.environ['OS_USERNAME']
    PASSWORD = os.environ['OS_PASSWORD']
except KeyError:
    logging.error('Please source your OpenStack openrc file.')
    raise


def get_object_by_id(objects, identifier):
    """get_object_by_id

    Returns the object which belongs to the given ID. Returns None if it wasn't
    found.
    """
    logging.debug('Searching for %s inside %s', identifier, objects)
    for obj in objects:
        if obj.id == identifier or obj.name == identifier:
            return obj
    logging.info('Could not find %s inside %s', identifier, objects)
    return None


class Session(keystone_session.Session):
    """Session

    Maintains an OpenStack session which can be used by the clients.
    """

    def __init__(self):
        auth = v3.Password(
            auth_url=AUTH_URL,
            username=USERNAME,
            password=PASSWORD,
            project_id=PROJECT_ID,
            user_domain_name='Default')
        keystone_session.Session.__init__(self, auth=auth)


class Plot(object):
    """Plot

    Generates a graph and converts it to a base64-decoded PNG file.
    """
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self._png_file = BytesIO()

        pyplot.xlim(1.1 * width)
        pyplot.ylim(1.1 * height)
        pyplot.gca().invert_xaxis()
        pyplot.gca().invert_yaxis()

    def __del__(self):
        """__del__

        Make sure the plot is cleared when this object is destructed.
        """
        pyplot.clf()

    def add_graph(self, x, y):
        """add_graph

        Turn two lists representing x and y values into a plot and add it to
        the graph.
        """
        pyplot.plot(x[:len(y)], y[:len(x)])

    def add_box(self, width, height, color='b'):
        """add_box

        Add a box with a given width and height of a given color (blue by
        default) to the graph.
        """
        rect = patches.Rectangle(
            (0, 0),
            width,
            height,
            linewidth=1,
            edgecolor=color,
            facecolor='none')
        pyplot.gca().add_patch(rect)

    @property
    def png(self):
        """png

        Saves the current plot to the in-memory PNG file and returns the file.
        """
        pyplot.savefig(self._png_file, format='png')
        return self._png_file

    @property
    def base64(self):
        """base64

        Returns a base64-decoded string of the graph.
        """
        image = self.png.getvalue()
        return base64.encodestring(image).decode('utf-8')


class Report(object):
    """Report

    A Report object generates a report in the form of a HTML-page of a list of
    hypervisors and information about how certain migrations improve the
    resource distribution.
    """

    def __init__(self, inventory):
        self._inventory = inventory

    def _generate_hypervisor_report(self, hypervisor):
        """_plot_hypervisor

        Returns the report for a single hypervisor.
        """
        def dict_to_table(dictionary):
            """dict_to_table

            Converts a dictionary to an HTML table.
            """
            table_contents = ''
            for key, value in dictionary.items():
                if isinstance(value, list):
                    _value = '<br />'.join(value)
                else:
                    _value = str(value)

                table_contents += '<tr>'
                table_contents += '<th scope="row" valign="top" align="right">'
                table_contents += '{}</th><td>{}</td>'.format(key, _value)

            return '<table>{}</table>'.format(table_contents)

        plot = '<img src="data:image/png;base64,' + hypervisor.plot + '"/>'
        table = dict_to_table(hypervisor.to_dict())

        return '<div class="row">' + \
               '<div class="column">{}</div>'.format(table) + \
               '<div class="column">{}</div>'.format(plot) + \
               '</div>'

    @property
    def head(self):
        """head

        Returns the HTML head of the report.
        """
        return '<head><style>' + \
               'th,td{ border-bottom: 1px solid #ddd; }' + \
               'tr:hover{ background-color:#f5f5f5; }.column{' + \
               'float:left;width:50%;padding:10px;height:100%;}' + \
               '*{box-sizing:border-box;}' + \
               '</style></head>'

    @property
    def body(self):
        """body

        Returns the HTML body of the report.
        """
        body = '<h1>Migration report</h>'
        for hypervisor in self._inventory.hypervisors:
            body += self._generate_hypervisor_report(hypervisor)

        return '<body>{}</body>'.format(body)

    @property
    def page(self):
        """page

        Returns the report as HTML.
        """
        return '<html>{}{}</html>'.format(self.head, self.body)


class Inventory(object):
    """Inventory

    An object containing Hypervisor and VM objects which are fetched using the
    OpenStack API.
    """

    def __init__(self, novaclient, config={}):
        self._client = novaclient
        self._config = config
        self._hypervisors = []
        self._vms = []
        self._flavors = []

    def to_dict(self):
        """to_dict

        Returns the inventory as a dictionary.
        """
        return {
                'common_ratio': self.common_ratio,
                'inventory': [ h.to_dict() for h in self.hypervisors ]
                }

    def generate_report(self):
        """generate_report

        A messy method which generates a report in HTML-format.
        """
        report = Report(self)
        return report.page

    @property
    def hypervisors(self):
        """hypervisors

        Returns a list of hypervisors as CustomHypervisor objects. If it's the
        first time the list is being called, the VM's are attached to their
        hypervisors.
        """
        if not self._hypervisors:
            self._hypervisors = [
                    CustomHypervisor(h, self.common_ratio, self._config)
                    for h in self._client.hypervisors.list() ]

            for vm in self.vms:
                hypervisor = get_object_by_id(self._hypervisors, vm.hypervisor)
                if not hypervisor:
                    raise ValueError('Unknown hypervisor for %s (status: %s)',
                            vm.name, vm.status)
                hypervisor.add_server(vm)

        return self._hypervisors

    @property
    def vms(self):
        """vms

        Returns a list of VM's as CustomServer objects.
        """
        if not self._vms:
            opts = { 'all_tenants': True }
            self._vms = [ CustomServer(vm, self.flavors) \
                    for vm in self._client.servers.list(search_opts=opts)
                    if vm.status != 'SHELVED_OFFLOADED' ]

        return self._vms

    @property
    def common_ratio(self):
        """common_ratio

        Returns the most common ratio amongst all VMs.
        """
        ratios = [ vm.ratio for vm in self.vms ]
        return max(ratios, key=ratios.count)

    @property
    def flavors(self):
        """flavors

        Returns a list of Flavors.
        """
        if not self._flavors:
            self._flavors = self._client.flavors.list(is_public=None)

        return self._flavors

    def optimize(self):
        """optimize

        Generates and returns a list of migrations to improve Hypervisor
        resource distribution.
        """
        # TODO
        return []


class CustomHypervisor(Hypervisor):
    """CustomHypervisor

    A CustomHypervisor object contains information about its available resources
    and the VMs it hosts.
    """

    def __init__(self, hypervisor, common_ratio, config={}):
        Hypervisor.__init__(self, hypervisor.manager, hypervisor._info)
        self._servers = []
        self._common_ratio = common_ratio
        self._ram_overcommit = config.get('ram_overcommit', 1)
        self._cpu_overcommit = config.get('cpu_overcommit', 4)
        self._memory_overhead = config.get('hypervisor_memory_overhead', 32768)
        logging.debug('Initialized hypervisor: %s', self.id)

    def to_dict(self):
        """to_dict

        Returns the hypervisor as a dict.
        """
        dictionary = {
            'name': self.name,
            'score': self.score(self._common_ratio),
            'enabled': self.enabled,
            'vcpus': self.vcpus * self._cpu_overcommit,
            'vcpus_used': self.vcpus_used,
            'memory_mb': self.memory_mb * self._ram_overcommit,
            'memory_mb_used': self.memory_mb_used,
            'vms': [ s.name for s in self._servers ],
        }
        return dictionary

    @property
    def plot(self):
        """plot

        Generates a plot of the hypervisor and its resources and returns it as a
        Base64 decoded string.
        """
        # Generate a plot
        width = self.memory_mb * self._ram_overcommit - self._memory_overhead
        height = self.vcpus * self._cpu_overcommit
        plot = Plot(width, height)

        # Draw graphs representing VMs
        x = [ i for i in range(width) ]
        y = [ 0 ]
        for vm in self._servers:
            dy_dx = vm.vcpus / vm.ram
            for _ in range(vm.ram):
                y.append(y[-1] + dy_dx)
        plot.add_graph(x, y)

        # Draw box representing hypervisor resources
        plot.add_box(width, height)

        # Draw graphs representing common ratio
        dx = self._common_ratio
        x = []
        y = []
        next_x = width
        next_y = height
        while next_x >= 0 and next_y >= 0:
            x.append(next_x)
            y.append(next_y)
            next_x -= dx
            next_y -= 1
        plot.add_graph(x, y)

        return plot.base64

    @property
    def name(self):
        """name

        Returns the hypervisor domain name.
        """
        return self.hypervisor_hostname

    @property
    def enabled(self):
        """enabled

        Returns True if the hypervisor is enabled.
        """
        return self.status == 'enabled'

    @property
    def available_ram(self):
        """available_ram

        Returns the amount of available RAM in MB's, taking memory overhead and
        the overcommit ratio into account. Note that memory overhead is already
        calculated into `self.memory_mb_used`.
        """
        available_ram = self.memory_mb * self._ram_overcommit \
            - self.memory_mb_used

        if available_ram < 0:
            logging.warning('Used memory above overcommit treshold on %s',
                    self.name)

        return available_ram

    @property
    def available_vcpus(self):
        """available_vcpus

        Returns the number of available VCPU's.
        """
        available_vcpus = self.vcpus * self._cpu_overcommit - self.vcpus_used

        if available_vcpus < 0:
            logging.warning('Used vCPUS above overcommit treshold on %s',
                    self.name)

        return available_vcpus

    @property
    def ratio(self):
        """ratio

        Returns the ratio between the available RAM (in MB's) and the available
        number of vCPU's.
        """
        if not self.available_vcpus:
            return self.available_ram
        return int(self.available_ram / self.available_vcpus)

    def score(self, common_ratio):
        """score

        Returns a score based on the difference between the most common RAM/vCPU
        ratio amongst VMs and the RAM/vCPU ratio of available resources of this
        hypervisor. The closer to zero, the better the score.
        """
        def _sigmoid(x):
            """_sigmoid

            A sigmoid-like function.
            """
            return x / (1 + abs(x))

        # TODO: Account for CPU/RAM cost
        weight_ram = _sigmoid( self.available_ram / self.memory_mb )
        weight_vcpus = _sigmoid( self.available_vcpus / self.vcpus )
        angle = atan(common_ratio) - atan(self.ratio)
        return angle * (weight_ram + weight_vcpus)

    def add_server(self, server):
        """add_server

        Adds an OpenStack instance to the Hypervisor.
        """
        self._servers.append(server)


class CustomServer(Server):
    """CustomServer

    A CustomServer object contains information about an OpenStack instance and
    the resources it needs.
    """

    def __init__(self, server, flavors):
        Server.__init__(self, server.manager, server._info)
        self._flavor = get_object_by_id(flavors, self.flavor['id'])
        logging.debug('Initialized server: %s', self.id)

    @property
    def ram(self):
        """ram

        Returns the memory which is assigned to this server in MB's.
        """
        return self._flavor.ram

    @property
    def vcpus(self):
        """vcpus

        Returns the number of virtual CPU's which are assigned to this server.
        """
        return self._flavor.vcpus

    @property
    def ratio(self):
        """ratio

        Returns the RAM/vCPU ratio, rounded down to the nearest integer to allow
        ratio comparison as it prevents floating point comparison issues.
        """
        return int(self.ram/self.vcpus)

    @property
    def hypervisor(self):
        """hypervisor

        Returns the hypervisor hostname.
        """
        return self.__getattr__('OS-EXT-SRV-ATTR:hypervisor_hostname')


def parse_config(filename):
    """parse_config

    Load a certain YAML-file and return its contents as a dictionary.
    """
    try:
        with open(filename, 'r') as config:
            return yaml.safe_load(config)
    except Exception as e:
        logging.error('Could not load %s: %s', filename, e)
        exit(1)


def parse_args():
    """parse_args

    As always, parse given arguments using the usual argparse module and return
    the parsed args object.
    """
    parser = argparse.ArgumentParser(description="""
       _|_|_|            _|                  _|                  _|
     _|          _|_|    _|_|_|      _|_|_|  _|_|_|      _|_|_|  _|  _|
       _|_|    _|    _|  _|    _|  _|        _|    _|  _|    _|  _|_|
           _|  _|    _|  _|    _|  _|        _|    _|  _|    _|  _|  _|
     _|_|_|      _|_|    _|_|_|      _|_|_|  _|    _|    _|_|_|  _|    _|

> You mark that frame an eight, you're entering a world of pain. A world of
> pain.
                                                              ~ Walter Sobchak

Sobchak is your friendly neighbourhood OpenStack instance scheduling optimizer,
which generates a list of instance migrations to optimally make use of
hypervisor resources.
""", formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('-c', '--configfile', action='store',
                        help='Configuration file.')
    parser.add_argument('-d', '--debug',
                        help='Enable debug', action='store_true')
    parser.add_argument('-R', '--generate-report',
                        help='Generate a report', action='store_true')

    return parser.parse_args()


def run(configfile, debug, generate_report):
    """run

    Actually run the program; fetch a Hypervisor-VM inventory and determine
    which migrations can be executed to improve the current resource
    distribution.
    """
    if debug:
        logging.basicConfig(
            level=logging.DEBUG,
            format='%(asctime)s %(levelname)-8s %(message)s'
        )

    # Parse configfile (if given)
    config = {}
    if configfile:
        config = parse_config(configfile)
        logging.debug('Loaded config: %s', config)

    # Create OpenStack Nova client
    sess = Session()
    keystone = keystone_client.Client(session=sess)
    nova = nova_client.Client('2', session=sess)

    # Create inventory
    inventory = Inventory(nova, config)

    # Generate report (if needed)
    if generate_report:
        with open('report.html', 'w+') as report:
            report.write(inventory.generate_report())
            print('Report available: {}'.format(os.path.abspath('report.html')))

if __name__ == "__main__":
    args = parse_args()
    kwargs = vars(args)
    run(**kwargs)
