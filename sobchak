#!/usr/bin/env python3

# Sobchak
# An OpenStack instance scheduling optimizer.

VERSION = '0.1'

import logging
import argparse
import os
import base64

from matplotlib import pyplot, patches
from io import BytesIO
from math import atan, sqrt, sin

from keystoneauth1.identity import v3
from keystoneauth1 import session as keystone_session
from keystoneclient.v3 import client as keystone_client
from novaclient import client as nova_client

from novaclient.v2.servers import Server
from novaclient.v2.hypervisors import Hypervisor

from time import sleep

# Load openrc values
try:
    PROJECT_ID = os.environ['OS_PROJECT_ID']
    AUTH_URL = os.environ['OS_AUTH_URL']
    USERNAME = os.environ['OS_USERNAME']
    PASSWORD = os.environ['OS_PASSWORD']
except KeyError:
    logging.error('Please source your OpenStack openrc file.')
    raise


def sigmoid(x):
    """sigmoid

    A sigmoid-like function.
    """
    return x / (1 + abs(x))

def get_object_by_id(objects, identifier):
    """get_object_by_id

    Returns the object which belongs to the given ID. Returns None if it wasn't
    found.
    """
    logging.debug('Searching for %s inside %s', identifier, objects)
    for obj in objects:
        if obj.id == identifier or obj.name == identifier:
            return obj
    logging.info('Could not find %s inside %s', identifier, objects)
    return None


class Session(keystone_session.Session):
    """Session

    Maintains an OpenStack session which can be used by the clients.
    """
    def __init__(self):
        auth = v3.Password(
            auth_url=AUTH_URL,
            username=USERNAME,
            password=PASSWORD,
            project_id=PROJECT_ID,
            user_domain_name='Default')
        keystone_session.Session.__init__(self, auth=auth)


class Migration(object):
    """Migration

    Contains information about a migration; a VM, a source and a destination.
    """
    def __init__(self, server, source, destination):
        self.server = server
        self.source = source
        self.destination = destination

    def __str__(self):
        return 'openstack server migrate {} --host {} #{} from {} to {}'.format(
                self.server.id, self.destination.name, self.server, self.source,
                self.destination)

    def __repr__(self):
        return self.__str__()

    @property
    def reverse(self):
        """reverse

        Returns the opposite migration.
        """
        return Migration(self.server, self.destination, self.source)


class Plot(object):
    """Plot

    Generates a graph and converts it to a base64-decoded PNG file.
    """
    def __init__(self, width, height, title, xlabel, ylabel):
        self.width = width
        self.height = height
        self._png_file = BytesIO()

        pyplot.xlim(1.1 * width)
        pyplot.ylim(1.1 * height)
        pyplot.gca().invert_xaxis()
        pyplot.gca().invert_yaxis()
        pyplot.title(title)
        pyplot.xlabel(xlabel)
        pyplot.ylabel(ylabel)

    def __del__(self):
        """__del__

        Make sure the plot is cleared when this object is destructed.
        """
        pyplot.clf()

    def add_graph(self, x, y, label):
        """add_graph

        Turn two lists representing x and y values into a plot and add it to
        the graph.
        """
        pyplot.plot(x[:len(y)], y[:len(x)], label=label)

    def add_box(self, width, height, label=None, facecolor='none', color='b'):
        """add_box

        Add a box with a given width and height of a given color (blue by
        default) to the graph.
        """
        rect = patches.Rectangle(
            (0, 0),
            width,
            height,
            linewidth=1,
            edgecolor=color,
            label=label,
            facecolor=facecolor)
        pyplot.gca().add_patch(rect)

    @property
    def png(self):
        """png

        Saves the current plot to the in-memory PNG file and returns the file.
        """
        pyplot.legend(loc='lower right')
        pyplot.savefig(self._png_file, format='png')
        return self._png_file

    @property
    def base64(self):
        """base64

        Returns a base64-decoded string of the graph.
        """
        image = self.png.getvalue()
        return base64.encodestring(image).decode('utf-8')


class Report(object):
    """Report

    A Report object generates a report in the form of a HTML-page of a list of
    hypervisors and information about how certain migrations improve the
    resource distribution.
    """
    def __init__(self, inventory, template='template.html'):
        self._inventory = inventory
        self._migration_report = ''
        self._template = self._fetch_template(template)
        self.title = 'Migration report'

    def _fetch_template(self, filename):
        """_fetch_template

        Reads a template and returns the contents.
        """
        try:
            with open(filename, 'r') as template:
                return template.read()
        except Exception as e:
            logging.error('Could not load %s: %s', filename, e)
            exit(1)

    def add_migrations(self, migrations):
        """add_migrations

        Adds the migrations to the report.
        """
        code_block = lambda c: '<pre><code>' + c + '</code></pre>'
        migration_list = '<br />'.join([str(m) for m in migrations])
        self._migration_report = code_block(migration_list)

    @property
    def body(self):
        """body

        Returns the HTML body of the report.
        """
        img_tag = lambda i: \
            '<img width="25%" src="data:image/png;base64,{}"/>'.format(i)

        body = '<h1>{}</h1>'.format(self.title)

        body += '<h2>Hypervisor info</h2>'
        for hypervisor in self._inventory.hypervisors:
            body += img_tag(hypervisor.plot)

        body += '<h2>Migration list</h2>'
        body += self._migration_report

        return body

    @property
    def page(self):
        """page

        Returns the report as HTML.
        """
        variables = {
            'title': self.title,
            'body': self.body
        }
        content = self._template

        for key, value in variables.items():
            content = content.replace('{{'+key+'}}', value)

        return content


class Inventory(object):
    """Inventory

    An object containing Hypervisor and VM objects which are fetched using the
    OpenStack API.
    """
    def __init__(self, novaclient, config={}):
        self._client = novaclient
        self._config = config
        self._hypervisors = []
        self._vms = []
        self._flavors = []

    def to_dict(self):
        """to_dict

        Returns the inventory as a dictionary.
        """
        return {
                'common_ratio': self.common_ratio,
                'inventory': [ h.to_dict() for h in self.hypervisors ]
                }

    def snapshot(self, validate=True):
        """snapshot

        Saves a snapshot of the current inventory.
        """
        logging.debug('Taking snapshot')
        for hypervisor in self.hypervisors:
            hypervisor.snapshot(validate)

    def use_snapshot(self, index=-1, validate=True):
        """use_snapshot

        Reverts to the last snapshot.
        """
        logging.debug('Reverting to snapshot')
        for hypervisor in self.hypervisors:
            hypervisor.use_snapshot(index, validate)

    @property
    def hypervisors(self):
        """hypervisors

        Returns a list of hypervisors as CustomHypervisor objects. If it's the
        first time the list is being called, the VM's are attached to their
        hypervisors.
        """
        if not self._hypervisors:
            logging.info('Fetching hypervisor info')
            self._hypervisors = [
                    CustomHypervisor(h, self.common_ratio, self._config)
                    for h in self._client.hypervisors.list() ]

            for vm in self.vms:
                hypervisor = get_object_by_id(self._hypervisors, vm.hypervisor)
                if hypervisor:
                    hypervisor.add_server(vm, force=True)
                else:
                    logging.warning('Unknown hypervisor for %s (status: %s)',
                            vm, vm.status)

            self.snapshot()

        return self._hypervisors

    @property
    def vms(self):
        """vms

        Returns a list of VM's as CustomServer objects.
        """
        if not self._vms:
            logging.info('Fetching VM info')
            opts = { 'all_tenants': True }
            self._vms = [ CustomServer(vm, self.flavors) \
                    for vm in self._client.servers.list(search_opts=opts)
                    if vm.status != 'SHELVED_OFFLOADED' ]

        return self._vms

    @property
    def enabled_hypervisors(self):
        """enabled_hypervisors

        Returns a list of enabled hypervisors.
        """
        return [h for h in self.hypervisors if h.enabled]

    @property
    def left_divergent(self):
        """left_divergent

        Returns the enabled hypervisor which is the most divergent to the left
        and has a negative score, so it can help. Returns None if no hypervisors
        fit that profile.
        """
        candidate_hypervisors = [h for h in self.enabled_hypervisors \
                if h.score < 0]
        if candidate_hypervisors:
            return max(candidate_hypervisors, key=lambda h: h.divergence[0])
        else:
            return None

    @property
    def right_divergent(self):
        """right_divergent

        Returns the enabled hypervisor which is the most divergent to the right
        and has a positive score, so it can help. Returns None if no hypervisors
        fit that profile.
        """
        candidate_hypervisors = [h for h in self.enabled_hypervisors \
                if h.score > 0]
        if candidate_hypervisors:
            return max(candidate_hypervisors, key=lambda h: h.divergence[1])
        else:
            return None

    @property
    def common_ratio(self):
        """common_ratio

        Returns the most common ratio amongst all VMs.
        """
        ratios = [ vm.ratio for vm in self.vms ]
        return max(ratios, key=ratios.count)

    @property
    def flavors(self):
        """flavors

        Returns a list of Flavors.
        """
        if not self._flavors:
            self._flavors = self._client.flavors.list(is_public=None)

        return self._flavors

    def _validate_migrations(self, migrations):
        """_validate_migrations

        Validate a list of migrations on several points:

        * No duplicate VMs
        * Migrations - in order - are possible after last snapshot
        * Same amount of VMs
        * Disabled hypervisors are left alone
        """
        self.use_snapshot(0)

        # Check for duplicate VMs
        vm_ids = [vm.id for vm in self.vms]
        assert len(vm_ids) == len(set(vm_ids))

        number_of_vms = len(self.vms)

        # Check for valid migration list
        for migration in migrations:
            assert migration.source.enabled
            assert migration.destination.enabled
            assert migration.source.remove_server(migration.server)
            assert migration.destination.add_server(migration.server)

        # Check for number of VMs
        assert number_of_vms == len(self.vms)

        # Check for duplicate VMs
        vm_ids = [vm.id for vm in self.vms]
        assert len(vm_ids) == len(set(vm_ids))

        logging.info('Validated migration list')

    def _increase_buffer(self, hypervisor, skip_hypervisor_ids=[],
            skip_server_ids=[]):
        """_increase_buffer

        Returns a migration which will temporarily give a given hypervisor extra
        available resources. Does not use the hypervisors given in `skip` as a
        buffer.
        """
        potential_buffers = [h for h in self.enabled_hypervisors \
                if h.id not in skip_hypervisor_ids and \
                h.id != hypervisor.id]
        servers = [s for s in hypervisor.servers if s.id not in skip_server_ids]

        buffers = reversed(sorted(potential_buffers,
                key=lambda h: h.available_vcpus * h.available_ram))

        sorted_servers = reversed(sorted(servers, key=lambda s: s.length))

        for buff in buffers:
            for server in sorted_servers:
                if buff.add_server(server):
                    assert hypervisor.remove_server(server)
                    return Migration(server, hypervisor, buff)

        logging.warning('Could not find available resources to migrate!')
        return None

    def _try_migration(self, migration):
        """_try_migration

        Tries a migration and adds a migration to a buffer hypervisor if needed.
        Returns a tuple containing lists of migrations and optional post
        migrations.
        """
        assert migration.source.remove_server(migration.server)
        migrations = []
        post_migrations = []
        while not migration.destination.add_server(migration.server):
            logging.info('Unable to migrate server %s, adding buffer.',
                    migration.server)
            buffer_migration = self._increase_buffer(migration.destination,
                    skip_hypervisor_ids=[migration.source.id],
                    skip_server_ids=[migration.server.id])
            if buffer_migration:
                migrations.append(buffer_migration)
                post_migrations.append(buffer_migration.reverse)
            else:
                migration.source.add_server(migration.server)
                return None
        migrations.append(migration)
        return (migrations, post_migrations)

    def _plan_migrations(self, needed_migrations):
        """_plan_migrations

        Takes a list of Migration objects and determines which actual migrations
        need to be done to realize this (as some migrations will not be possible
        due to insufficient available resources). Returns a list of Migration
        objects or an empty list if it's not possible.
        """
        migrations = []
        skip_servers = []

        for migration in needed_migrations:
            if migration.server in skip_servers:
                skip_servers.remove(migration.server)
                continue
            new_migrations = self._try_migration(migration)
            if not new_migrations:
                logging.warning('Could not get enough free resources.')
                self.use_snapshot()
                return []
            new_migration, post_migrations = new_migrations
            migrations.extend(new_migration)
            for post_migration in post_migrations:
                if post_migration.server in [m.server for m in \
                        needed_migrations if m not in migrations]:
                    skip_servers.append(post_migration.server)
                    destinations = [m.destination for m in needed_migrations \
                            if m.server == post_migration.server]
                    assert len(destinations) == 1
                    post_migration.destination = destinations[0]
                needed_migrations.append(post_migration)

        return migrations

    def _score_with_vm(self, hypervisor, vm):
        """_score_with_vm

        Returns the score a hypervisor would have if it hosted a given VM.
        """
        if not hypervisor.add_server(vm):
            return hypervisor.score
        else:
            score = hypervisor.score
            assert hypervisor.remove_server(vm)
            return score

    def _mix_hypervisors(self, subject, improvement):
        """_mix_hypervisors

        Takes two hypervisors (a `subject` which is to be improved and an
        `improvement` which has the divergence which enables the improvement)
        and mixes their VMs to improve the overall score.

        Returns a list of migrations if the combined score is lowered, otherwise
        returns None. Also returns None if the VMs do not fit on the two
        hypervisors (e.g. due to bad scheduling).

        Note that the list of migrations that is generated does not take
        hypervisor resources into account, so shuffling between a third node is
        needed when there's not enough free resources to migrate certain VMs.
        """
        logging.info('Mixing %s and %s', subject.name, improvement.name)
        score_before = abs(subject.score) + abs(improvement.score)
        subject_vms = subject.pop()
        improvement_vms = improvement.pop()
        vms = subject_vms + improvement_vms

        while vms:
            best_vm = min(vms,
                    key=lambda vm: abs(self._score_with_vm(subject, vm)))
            if not subject.add_server(best_vm):
                break
            vms.remove(best_vm)

        for vm in vms:
            if not improvement.add_server(vm):
                logging.warning('Could not fit VMs in hypervisors!')
                subject.servers = subject_vms
                improvement.servers = improvement_vms
                return None

        score_after = abs(subject.score) + abs(improvement.score)
        logging.info('Score from %f to %f', score_before, score_after)
        if score_after >= score_before:
            subject.servers = subject_vms
            improvement.servers = improvement_vms
            return None

        return [Migration(s, improvement, subject) for s in subject.servers \
                if s not in subject_vms] + \
               [Migration(s, subject, improvement) for s in improvement.servers \
                if s not in improvement_vms]

    def optimize(self, migrations=[], iterations=3):
        """optimize

        Generates and returns a list of migrations to improve Hypervisor
        resource distribution.
        """
        if iterations == 0:
            return migrations

        for subject in reversed(sorted(self.enabled_hypervisors, \
                key=lambda h: abs(h.score))):
            if subject.score < 0:
                improvement = self.right_divergent
            else:
                improvement = self.left_divergent

            if not improvement:
                continue

            needed_migrations = self._mix_hypervisors(subject, improvement)
            self.use_snapshot(validate=False)
            if needed_migrations:
                migrations.extend(self._plan_migrations(needed_migrations))

                # Final optimization; merge successive migrations of the same VM
                optimizing = True
                while optimizing:
                    optimizing = False
                    for i in range(len(migrations) - 1):
                        if migrations[i].server == migrations[i+1].server:
                            optimizing = True
                            migrations = migrations[:i] + \
                                    [Migration(migrations[i].server,
                                            migrations[i].source,
                                            migrations[i+1].destination)] + \
                                    migrations[i+2:]
                            break

                self.snapshot(validate=False)
                self._validate_migrations(migrations)
                return self.optimize(migrations=migrations,
                        iterations=iterations-1)

        return migrations


class CustomHypervisor(Hypervisor):
    """CustomHypervisor

    A CustomHypervisor object contains information about its available resources
    and the VMs it hosts.
    """
    def __init__(self, hypervisor, common_ratio, config={}):
        Hypervisor.__init__(self, hypervisor.manager, hypervisor._info)
        self.servers = []
        self._server_snapshot = []
        self._common_ratio = common_ratio
        self._ram_overcommit = config.get('ram_overcommit', 1)
        self._cpu_overcommit = config.get('cpu_overcommit', 4)
        self._memory_overhead = config.get('hypervisor_memory_overhead', 32768)
        self._gave_cpu_warning = False
        self._gave_ram_warning = False
        logging.debug('Initialized hypervisor: %s', self.id)

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.__str__()

    def snapshot(self, validate=True):
        """snapshot

        Saves the current VM list.
        """
        self._server_snapshot.append([s for s in self.servers])
        if validate:
            self.verify_available_resources()

    def use_snapshot(self, index=-1, validate=True):
        """use_snapshot

        Resets the VM list to the last snapshot.
        """
        self.servers = [s for s in self._server_snapshot[index]]
        if validate:
            self.verify_available_resources()

    def verify_available_resources(self):
        """verify_available_resources

        Checks if OpenStack agrees with our calculated available resources.
        """
        available_vcpus_check = self.vcpus * self._cpu_overcommit \
                - self.vcpus_used
        if not self.available_vcpus == available_vcpus_check:
            logging.error('Calculated available VCPUs (%i) is not %i',
                    self.available_vcpus, available_vcpus_check)
            logging.error('Please check the configuration.')
            exit(1)

        available_ram_check = self.memory_mb * self._ram_overcommit \
                - self.memory_mb_used
        if not self.available_ram == available_ram_check:
            logging.error('Calculated available RAM (%i) is not %i',
                    self.available_vcpus, available_vcpus_check)
            logging.error('Please check the configuration.')
            exit(1)

    def to_dict(self):
        """to_dict

        Returns the hypervisor as a dict.
        """
        dictionary = {
            'name': self.name,
            'score': self.score,
            'divergence': self.divergence,
            'enabled': self.enabled,
            'vcpus': self.vcpus * self._cpu_overcommit,
            'vcpus_used': self.vcpus_used,
            'memory_mb': self.memory_mb * self._ram_overcommit,
            'memory_mb_used': self.memory_mb_used,
            'vms': [ s.name for s in self.servers ],
        }
        return dictionary

    @property
    def plot(self, include_snapshot=True):
        """plot

        Generates a plot of the hypervisor and its resources and returns it as a
        Base64 decoded string.

        Warning: enabling `include_snapshot` will actually revert the hypervisor
        to the last snapshot!
        """
        # Generate a plot
        width = self.memory_mb * self._ram_overcommit - self._memory_overhead
        height = self.vcpus * self._cpu_overcommit
        plot = Plot(width, height, self.name, 'memory [MB]', 'VCPUs')

        # Draw graphs representing VMs
        def _generate_data(servers):
            x = [ i for i in range(width) ]
            y = [ 0 ]
            for vm in servers:
                dy_dx = vm.vcpus / vm.ram
                for _ in range(vm.ram):
                    y.append(y[-1] + dy_dx)
            return x, y

        x, y = _generate_data(self.servers)
        plot.add_graph(x, y, 'Hosted VMs (after)')

        if include_snapshot:
            self.use_snapshot(0)
            x, y = _generate_data(self.servers)
            plot.add_graph(x, y, 'Hosted VMs (before)')

        # Grey-out graph if hypervisor is disabled
        if not self.enabled:
            plot.add_box(1.1*width, 1.1*height, facecolor=(0.8,)*3)

        # Draw box representing hypervisor resources
        plot.add_box(width, height, 'Available resources')

        # Draw graphs representing common ratio
        dx = self._common_ratio
        x = []
        y = []
        next_x = width
        next_y = height
        while next_x >= 0 and next_y >= 0:
            x.append(next_x)
            y.append(next_y)
            next_x -= dx
            next_y -= 1
        plot.add_graph(x, y, 'Most common resource ratio')

        return plot.base64

    @property
    def name(self):
        """name

        Returns the hypervisor domain name.
        """
        return self.hypervisor_hostname

    @property
    def enabled(self):
        """enabled

        Returns True if the hypervisor is enabled.
        """
        return self.status == 'enabled'

    @property
    def available_ram(self):
        """available_ram

        Returns the amount of available RAM in MB's, taking memory overhead and
        the overcommit ratio into account. Note that memory overhead is already
        calculated into `self.memory_mb_used`.
        """
        available_ram = self.memory_mb * self._ram_overcommit \
            - sum([ vm.ram for vm in self.servers ]) - self._memory_overhead

        if available_ram < 0 and not self._gave_ram_warning:
            logging.warning('Used memory above overcommit treshold on %s',
                    self.name)
            self._gave_ram_warning = True

        return available_ram

    @property
    def available_vcpus(self):
        """available_vcpus

        Returns the number of available VCPU's.
        """
        available_vcpus = self.vcpus * self._cpu_overcommit \
            - sum([ vm.vcpus for vm in self.servers ])

        if available_vcpus < 0 and not self._gave_cpu_warning:
            logging.warning('Used vCPUS above overcommit treshold on %s',
                    self.name)
            self._gave_cpu_warning = True

        return available_vcpus

    @property
    def ratio(self):
        """ratio

        Returns the ratio between the available RAM (in MB's) and the available
        number of vCPU's.
        """
        if not self.available_vcpus:
            return self.available_ram
        return int(self.available_ram / self.available_vcpus)

    @property
    def divergence(self):
        """divergence

        Returns a tuple containing the sum of left- and right-handed divergent
        VMs.
        """
        left = right = 0
        for vm in self.servers:
            divergence = vm.calculate_divergence(self._common_ratio)
            if divergence < 0:
                left -= divergence
            else:
                right += divergence
        return (left, right)

    @property
    def score(self):
        """score

        Returns a score based on the difference between the most common RAM/vCPU
        ratio amongst VMs and the RAM/vCPU ratio of available resources of this
        hypervisor. The closer to zero, the better the score.
        """
        # TODO: Account for CPU/RAM cost
        weight_ram = sigmoid(self.available_ram / self.memory_mb)
        weight_vcpus = sigmoid(self.available_vcpus / self.vcpus)
        angle = atan(self._common_ratio) - atan(self.ratio)
        return angle * (weight_ram + weight_vcpus)

    def pop(self):
        """pop

        Returns all servers and removes them from this hypervisor.
        """
        servers = self.servers
        self.servers = []
        return servers

    def add_server(self, server, force=False):
        """add_server

        Adds an OpenStack instance to the Hypervisor. Returns True if succeeded,
        else returns False.
        """
        if not force and (server.ram > self.available_ram or \
                server.vcpus > self.available_vcpus):
            return False
        logging.debug('Adding %s to %s', server.name, self)
        self.servers.append(server)
        return True

    def remove_server(self, server):
        """remove_server

        Removes a given VM from this hypervisor. Returns True on success,
        otherwise (e.g. if the VM wasn't found on this server) returns False.
        """
        logging.debug('Removing %s from %s', server.name, self)
        filtered_servers = [s for s in self.servers if not s == server]
        if len(filtered_servers) == len(self.servers) - 1:
            self.servers = filtered_servers
            return True
        else:
            logging.error('Error while removing server %s: VM count %i -> %i',
                    server.name, len(self.servers), len(filtered_servers))
            return False


class CustomServer(Server):
    """CustomServer

    A CustomServer object contains information about an OpenStack instance and
    the resources it needs.
    """
    def __init__(self, server, flavors):
        Server.__init__(self, server.manager, server._info)
        self._flavor = get_object_by_id(flavors, self.flavor['id'])
        logging.debug('Initialized server: %s', self.id)

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.__str__()

    def __eq__(self, other):
        return self.id == other.id

    @property
    def ram(self):
        """ram

        Returns the memory which is assigned to this server in MB's.
        """
        return self._flavor.ram

    @property
    def vcpus(self):
        """vcpus

        Returns the number of virtual CPU's which are assigned to this server.
        """
        return self._flavor.vcpus

    @property
    def ratio(self):
        """ratio

        Returns the RAM/vCPU ratio, rounded down to the nearest integer to allow
        ratio comparison as it prevents floating point comparison issues.
        """
        return int(self.ram/self.vcpus)

    @property
    def hypervisor(self):
        """hypervisor

        Returns the hypervisor hostname.
        """
        return self.__getattr__('OS-EXT-SRV-ATTR:hypervisor_hostname')

    @property
    def length(self):
        """length

        Returns the length of this VM's resource vector.
        """
        return sqrt(self.ram * self.ram + self.vcpus * self.vcpus)

    def calculate_divergence(self, reference):
        """calculate_divergence

        Returns the divergence from a reference slope. See README.md for more
        information about what this actually means.
        """
        angle = atan(self.ratio) - atan(reference)
        return self.length * sin(angle)


def parse_config(filename):
    """parse_config

    Load a certain YAML-file and return its contents as a dictionary.
    """
    try:
        with open(filename, 'r') as config:
            return yaml.safe_load(config)
    except Exception as e:
        logging.error('Could not load %s: %s', filename, e)
        exit(1)


def parse_args():
    """parse_args

    As always, parse given arguments using the usual argparse module and return
    the parsed args object.
    """
    parser = argparse.ArgumentParser(description="""
       _|_|_|            _|                  _|                  _|
     _|          _|_|    _|_|_|      _|_|_|  _|_|_|      _|_|_|  _|  _|
       _|_|    _|    _|  _|    _|  _|        _|    _|  _|    _|  _|_|
           _|  _|    _|  _|    _|  _|        _|    _|  _|    _|  _|  _|
     _|_|_|      _|_|    _|_|_|      _|_|_|  _|    _|    _|_|_|  _|    _|

> You mark that frame an eight, you're entering a world of pain. A world of
> pain.
                                                              ~ Walter Sobchak

Sobchak is your friendly neighbourhood OpenStack instance scheduling optimizer,
which generates a list of instance migrations to optimally make use of
hypervisor resources.
""", formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('-V', '--version',
                        help='Show version', action='store_true')
    parser.add_argument('-c', '--configfile', action='store',
                        help='Configuration file')
    parser.add_argument('-t', '--template', action='store',
                        help='HTML report template', default='template.html')
    parser.add_argument('-i', '--iterations', action='store', type=int,
                        help='Number of iterations (default: 3)', default=3)
    parser.add_argument('-v', '--verbose',
                        help='Enable verbose logs', action='store_true')
    parser.add_argument('-d', '--debug',
                        help='Enable debug logs', action='store_true')
    parser.add_argument('-R', '--generate-report',
                        help='Generate a report', action='store_true')

    return parser.parse_args()


def run(version, configfile, debug, verbose, generate_report, iterations,
        template):
    """run

    Actually run the program; fetch a Hypervisor-VM inventory and determine
    which migrations can be executed to improve the current resource
    distribution.
    """
    if version:
        print('Sobchak - v{}'.format(VERSION))
        exit(0)

    if verbose:
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s %(levelname)-8s %(message)s'
        )
    elif debug:
        logging.basicConfig(
            level=logging.DEBUG,
            format='%(asctime)s %(levelname)-8s %(message)s'
        )

    # Parse configfile (if given)
    config = {}
    if configfile:
        config = parse_config(configfile)
        logging.debug('Loaded config: %s', config)

    # Create OpenStack Nova client
    sess = Session()
    keystone = keystone_client.Client(session=sess)
    nova = nova_client.Client('2', session=sess)

    # Create inventory
    inventory = Inventory(nova, config)

    # Generate and print migration list
    migrations = inventory.optimize(iterations=iterations)
    print('\n'.join([str(m) for m in migrations]))

    # Generate report (if needed)
    if generate_report:
        report = Report(inventory, template)
        report.add_migrations(migrations)
        with open('report.html', 'w+') as f:
            f.write(report.page)
            print('Report available: {}'.format(os.path.abspath('report.html')))

if __name__ == "__main__":
    args = parse_args()
    kwargs = vars(args)
    run(**kwargs)
